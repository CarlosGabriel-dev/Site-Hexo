{"meta":{"version":1,"warehouse":"5.0.1"},"models":{"Asset":[{"_id":"node_modules\\hexo-theme-landscape\\source\\css\\style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"node_modules\\hexo-theme-landscape\\source\\fancybox\\jquery.fancybox.min.css","path":"fancybox/jquery.fancybox.min.css","modified":0,"renderable":1},{"_id":"node_modules\\hexo-theme-landscape\\source\\fancybox\\jquery.fancybox.min.js","path":"fancybox/jquery.fancybox.min.js","modified":0,"renderable":1},{"_id":"node_modules\\hexo-theme-landscape\\source\\js\\jquery-3.6.4.min.js","path":"js/jquery-3.6.4.min.js","modified":0,"renderable":1},{"_id":"node_modules\\hexo-theme-landscape\\source\\js\\script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"node_modules\\hexo-theme-landscape\\source\\css\\images\\banner.jpg","path":"css/images/banner.jpg","modified":0,"renderable":1}],"Cache":[{"_id":"source\\_posts\\hello-world.md","hash":"acad91ace80b80295b11a9b7ad4c29a2dcfdd8fb","modified":1718943959995},{"_id":"node_modules\\hexo-theme-landscape\\README.md","hash":"1a9b279e6dd29fd19245f913f0c4a316ffaa62db","modified":1718943980874},{"_id":"node_modules\\hexo-theme-landscape\\package.json","hash":"4bf95d52f77edf811f23f6d264a7493311a8d078","modified":1718943980871},{"_id":"node_modules\\hexo-theme-landscape\\LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1718943980413},{"_id":"node_modules\\hexo-theme-landscape\\_config.yml","hash":"b608c1f1322760dce9805285a602a95832730a2e","modified":1718943980928},{"_id":"node_modules\\hexo-theme-landscape\\languages\\de-DE.yml","hash":"d29d1c4256b7ed9df42f511c2ff0a23ad5fd6c1f","modified":1718943980930},{"_id":"node_modules\\hexo-theme-landscape\\languages\\de.yml","hash":"3ebf0775abbee928c8d7bda943c191d166ded0d3","modified":1718943980931},{"_id":"node_modules\\hexo-theme-landscape\\languages\\en-GB.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1718943980935},{"_id":"node_modules\\hexo-theme-landscape\\languages\\en.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1718943980938},{"_id":"node_modules\\hexo-theme-landscape\\languages\\default.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1718943980934},{"_id":"node_modules\\hexo-theme-landscape\\languages\\en-US.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1718943980937},{"_id":"node_modules\\hexo-theme-landscape\\languages\\es-ES.yml","hash":"7008a8fc91f18d2a735864817b8ebda30c7a2c66","modified":1718943980941},{"_id":"node_modules\\hexo-theme-landscape\\languages\\es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":1718943980944},{"_id":"node_modules\\hexo-theme-landscape\\languages\\fr-FR.yml","hash":"8d09dbdab00a30a2870b56f7c0a7ca7deafa7b88","modified":1718943980946},{"_id":"node_modules\\hexo-theme-landscape\\languages\\fr.yml","hash":"415e1c580ced8e4ce20b3b0aeedc3610341c76fb","modified":1718943980947},{"_id":"node_modules\\hexo-theme-landscape\\languages\\hu-HU.yml","hash":"712d18664898fa21ba38d4973e90ef41a324ea25","modified":1718943980950},{"_id":"node_modules\\hexo-theme-landscape\\languages\\hu.yml","hash":"284d557130bf54a74e7dcef9d42096130e4d9550","modified":1718943980952},{"_id":"node_modules\\hexo-theme-landscape\\languages\\it-IT.yml","hash":"2cb6dc2fab9bd2dbe1c8bb869a9e8bf85a564fdd","modified":1718943980954},{"_id":"node_modules\\hexo-theme-landscape\\languages\\it.yml","hash":"89b7d91306b2c1a0f3ac023b657bf974f798a1e8","modified":1718943980955},{"_id":"node_modules\\hexo-theme-landscape\\languages\\ja-JP.yml","hash":"08481267e0c112e1f6855620f2837ec4c4a98bbd","modified":1718943980957},{"_id":"node_modules\\hexo-theme-landscape\\languages\\ja.yml","hash":"a73e1b9c80fd6e930e2628b393bfe3fb716a21a9","modified":1718943980959},{"_id":"node_modules\\hexo-theme-landscape\\languages\\ko-KR.yml","hash":"19209ad8f9d4057e8df808937f950eb265e1db69","modified":1718943980960},{"_id":"node_modules\\hexo-theme-landscape\\languages\\ko.yml","hash":"881d6a0a101706e0452af81c580218e0bfddd9cf","modified":1718943980963},{"_id":"node_modules\\hexo-theme-landscape\\languages\\mn-MN.yml","hash":"b9e5f3e7c0c2f779cf2cfded6db847b5941637ca","modified":1718943980964},{"_id":"node_modules\\hexo-theme-landscape\\languages\\mn.yml","hash":"2e7523951072a9403ead3840ad823edd1084c116","modified":1718943980965},{"_id":"node_modules\\hexo-theme-landscape\\languages\\nl-NL.yml","hash":"5ebbc30021f05d99938f96dfff280392df7f91f0","modified":1718943980968},{"_id":"node_modules\\hexo-theme-landscape\\languages\\nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1718943980968},{"_id":"node_modules\\hexo-theme-landscape\\languages\\no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1718943980969},{"_id":"node_modules\\hexo-theme-landscape\\languages\\pt-PT.yml","hash":"0f852b6b228e6ea59aa3540574bb89b233f2a098","modified":1718943980971},{"_id":"node_modules\\hexo-theme-landscape\\languages\\pt.yml","hash":"57d07b75d434fbfc33b0ddb543021cb5f53318a8","modified":1718943980973},{"_id":"node_modules\\hexo-theme-landscape\\languages\\ru-RU.yml","hash":"360d11a28bb768afb1dd15f63fa7fd3a8cc547ee","modified":1718943980975},{"_id":"node_modules\\hexo-theme-landscape\\languages\\ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1718943980976},{"_id":"node_modules\\hexo-theme-landscape\\languages\\th-TH.yml","hash":"ebfdba9bc4842c829473c1e6e4544344f182724d","modified":1718943980977},{"_id":"node_modules\\hexo-theme-landscape\\languages\\th.yml","hash":"84a55b00aa01f03982be294e43c33a20e6d32862","modified":1718943980979},{"_id":"node_modules\\hexo-theme-landscape\\languages\\tr.yml","hash":"a1cdbfa17682d7a971de8ab8588bf57c74224b5b","modified":1718943980980},{"_id":"node_modules\\hexo-theme-landscape\\languages\\zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1718943980983},{"_id":"node_modules\\hexo-theme-landscape\\languages\\zh-CN.yml","hash":"1efd95774f401c80193eac6ee3f1794bfe93dc5a","modified":1718943980982},{"_id":"node_modules\\hexo-theme-landscape\\layout\\archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1718943980664},{"_id":"node_modules\\hexo-theme-landscape\\layout\\category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1718943980708},{"_id":"node_modules\\hexo-theme-landscape\\layout\\layout.ejs","hash":"0d1765036e4874500e68256fedb7470e96eeb6ee","modified":1718943980777},{"_id":"node_modules\\hexo-theme-landscape\\layout\\index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1718943980773},{"_id":"node_modules\\hexo-theme-landscape\\layout\\page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1718943980791},{"_id":"node_modules\\hexo-theme-landscape\\layout\\post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1718943980794},{"_id":"node_modules\\hexo-theme-landscape\\scripts\\fancybox.js","hash":"c857d7a5e4a5d71c743a009c5932bf84229db428","modified":1718943980844},{"_id":"node_modules\\hexo-theme-landscape\\layout\\tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1718943980812},{"_id":"node_modules\\hexo-theme-landscape\\layout\\_partial\\after-footer.ejs","hash":"377d257d5d16e0158a4405c72401517b074fd7ff","modified":1718943980558},{"_id":"node_modules\\hexo-theme-landscape\\layout\\_partial\\archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1718943980589},{"_id":"node_modules\\hexo-theme-landscape\\layout\\_partial\\archive.ejs","hash":"7cb70a7a54f8c7ae49b10d1f37c0a9b74eab8826","modified":1718943980611},{"_id":"node_modules\\hexo-theme-landscape\\layout\\_partial\\article.ejs","hash":"56597e951203dd662a6d2c817c7c4f1c920d4a25","modified":1718943980678},{"_id":"node_modules\\hexo-theme-landscape\\layout\\_partial\\footer.ejs","hash":"3656eb692254346671abc03cb3ba1459829e0dce","modified":1718943980727},{"_id":"node_modules\\hexo-theme-landscape\\layout\\_partial\\google-analytics.ejs","hash":"2ea7442ea1e1a8ab4e41e26c563f58413b59a3d0","modified":1718943980751},{"_id":"node_modules\\hexo-theme-landscape\\layout\\_partial\\gauges-analytics.ejs","hash":"21a1e2a3907d1a3dad1cd0ab855fe6735f233c74","modified":1718943980743},{"_id":"node_modules\\hexo-theme-landscape\\layout\\_partial\\head.ejs","hash":"f05bced793b0314d4f2ef0c993b3a51d0b7d203a","modified":1718943980760},{"_id":"node_modules\\hexo-theme-landscape\\layout\\_partial\\header.ejs","hash":"6a5033d189554c9a6d42e2ef7952ae5c9742648e","modified":1718943980767},{"_id":"node_modules\\hexo-theme-landscape\\layout\\_partial\\mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1718943980782},{"_id":"node_modules\\hexo-theme-landscape\\layout\\_partial\\sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1718943980802},{"_id":"node_modules\\hexo-theme-landscape\\layout\\_widget\\archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1718943980642},{"_id":"node_modules\\hexo-theme-landscape\\layout\\_widget\\category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1718943980701},{"_id":"node_modules\\hexo-theme-landscape\\layout\\_widget\\recent_posts.ejs","hash":"60c4b012dcc656438ff59997e60367e5a21ab746","modified":1718943980798},{"_id":"node_modules\\hexo-theme-landscape\\layout\\_widget\\tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1718943980808},{"_id":"node_modules\\hexo-theme-landscape\\layout\\_widget\\tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1718943980815},{"_id":"node_modules\\hexo-theme-landscape\\source\\css\\_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1718943980880},{"_id":"node_modules\\hexo-theme-landscape\\source\\css\\_variables.styl","hash":"ca28281423ae57d76b6c1eb91cd845fd4e518bd6","modified":1718943980882},{"_id":"node_modules\\hexo-theme-landscape\\source\\css\\style.styl","hash":"e55a1d92954ed20f6887f92dc727bb995a010a43","modified":1718943980925},{"_id":"node_modules\\hexo-theme-landscape\\source\\fancybox\\jquery.fancybox.min.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1718943980457},{"_id":"node_modules\\hexo-theme-landscape\\source\\js\\script.js","hash":"49773efcb2221bbdf2d86f3f5c5ff2d841b528cc","modified":1718943980867},{"_id":"node_modules\\hexo-theme-landscape\\layout\\_partial\\post\\category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1718943980691},{"_id":"node_modules\\hexo-theme-landscape\\layout\\_partial\\post\\gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1718943980733},{"_id":"node_modules\\hexo-theme-landscape\\layout\\_partial\\post\\date.ejs","hash":"f1458584b679545830b75bef2526e2f3eb931045","modified":1718943980717},{"_id":"node_modules\\hexo-theme-landscape\\layout\\_partial\\post\\title.ejs","hash":"4d7e62574ddf46de9b41605fe3140d77b5ddb26d","modified":1718943980819},{"_id":"node_modules\\hexo-theme-landscape\\layout\\_partial\\post\\tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1718943980806},{"_id":"node_modules\\hexo-theme-landscape\\layout\\_partial\\post\\nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1718943980786},{"_id":"node_modules\\hexo-theme-landscape\\source\\css\\_partial\\archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1718943980886},{"_id":"node_modules\\hexo-theme-landscape\\source\\css\\_partial\\comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1718943980894},{"_id":"node_modules\\hexo-theme-landscape\\source\\css\\_partial\\article.styl","hash":"2d1f6f79ebf9cb55ebdb3865a2474437eb2b37c6","modified":1718943980892},{"_id":"node_modules\\hexo-theme-landscape\\source\\css\\_partial\\header.styl","hash":"268d2989acb06e2ddd06cc36a6918c6cd865476b","modified":1718943980905},{"_id":"node_modules\\hexo-theme-landscape\\source\\css\\_partial\\footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1718943980898},{"_id":"node_modules\\hexo-theme-landscape\\source\\css\\_partial\\mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1718943980913},{"_id":"node_modules\\hexo-theme-landscape\\source\\css\\_partial\\highlight.styl","hash":"9cc3b2927d814f2f6e8e188f9d3657b94f4c6ef3","modified":1718943980908},{"_id":"node_modules\\hexo-theme-landscape\\source\\css\\_partial\\sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1718943980916},{"_id":"node_modules\\hexo-theme-landscape\\source\\css\\_partial\\sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1718943980918},{"_id":"node_modules\\hexo-theme-landscape\\source\\css\\_partial\\sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1718943980922},{"_id":"node_modules\\hexo-theme-landscape\\source\\css\\_util\\grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1718943980902},{"_id":"node_modules\\hexo-theme-landscape\\source\\css\\_util\\mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1718943980911},{"_id":"node_modules\\hexo-theme-landscape\\source\\js\\jquery-3.6.4.min.js","hash":"eda46747c71d38a880bee44f9a439c3858bb8f99","modified":1718943980856},{"_id":"node_modules\\hexo-theme-landscape\\source\\fancybox\\jquery.fancybox.min.js","hash":"6181412e73966696d08e1e5b1243a572d0f22ba6","modified":1718943980862},{"_id":"node_modules\\hexo-theme-landscape\\source\\css\\images\\banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1718943980840},{"_id":"public/2024/06/21/hello-world/index.html","hash":"66fd6522b07b670dbdafba41b6322595866110f3","modified":1718944415190},{"_id":"public/archives/index.html","hash":"f6c2b4297a2ab12094d2997320374f98792cac1c","modified":1718945184879},{"_id":"public/archives/2024/index.html","hash":"ab74a660f72f48c3c9a0a19550ce8a0fb1143b0e","modified":1718945184879},{"_id":"public/archives/2024/06/index.html","hash":"b770d8a17e28299996af133448e4e5048048c91e","modified":1718945184879},{"_id":"public/index.html","hash":"0fde70c1f51fb81cf675af297dfb2a2be83d9f3d","modified":1718945184879},{"_id":"public/fancybox/jquery.fancybox.min.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1718944415190},{"_id":"public/css/style.css","hash":"ddb3792605d744ab3d9f0a649c82b62e9b16daa6","modified":1718944415190},{"_id":"public/js/script.js","hash":"49773efcb2221bbdf2d86f3f5c5ff2d841b528cc","modified":1718944415190},{"_id":"public/fancybox/jquery.fancybox.min.js","hash":"6181412e73966696d08e1e5b1243a572d0f22ba6","modified":1718944415190},{"_id":"public/js/jquery-3.6.4.min.js","hash":"eda46747c71d38a880bee44f9a439c3858bb8f99","modified":1718944415190},{"_id":"public/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1718944415190},{"_id":"source\\_posts\\Algoritmos.md","hash":"b49cf13fb69ede3b2634ae721a48b813272d7297","modified":1718837519126},{"_id":"source\\_posts\\Busca Binária.md","hash":"beab58b57084f21f3cb4f3e2f758210819ef6ff5","modified":1718806433947},{"_id":"source\\_posts\\imagens.md","hash":"6e4e75a9a65f4e002bf02ed4caf784a344f434d6","modified":1718928892630},{"_id":"source\\_posts\\imagens\\Bubble.png","hash":"a20c3ed466d0e661fa2f396414cf0975d289f7bf","modified":1718836125448},{"_id":"source\\_posts\\imagens\\Insertion.png","hash":"1c181424b0e9fd8e0331a772d1397288b6789c8b","modified":1718836209787},{"_id":"source\\_posts\\imagens\\Quick.png","hash":"a4a6f983060f33474f7bf3fac60b75f751b04841","modified":1718836237130},{"_id":"source\\_posts\\imagens\\Merge.png","hash":"bdc22e7670204730cf9450901e20e3cd5aa2de56","modified":1718836255804},{"_id":"source\\_posts\\imagens\\Selection.png","hash":"3b58254e02c82d4ae7aadc61550b21b424902d7a","modified":1718836184393},{"_id":"source\\_posts\\imagens\\Tempo.png","hash":"227cf273ded2ede0f618446b88ecca69416d9095","modified":1718836304165},{"_id":"public/2024/06/19/imagens/index.html","hash":"3b6fca388f72b1adfcc532b443a5db5b9b514964","modified":1718945184879},{"_id":"public/2024/05/14/Busca Binária/index.html","hash":"dc05fc785457913113b57fffb13f550ce626f607","modified":1718945184879},{"_id":"public/2024/05/13/Algoritmos/index.html","hash":"73469fad86e7ec07ac41ae4c9fc4dd6fc0250266","modified":1718945184879},{"_id":"public/archives/2024/05/index.html","hash":"daf06ced5b6e27d4d7238a279852ec815d0f4870","modified":1718945184879},{"_id":"public/2024/06/19/imagens/Merge.png","hash":"bdc22e7670204730cf9450901e20e3cd5aa2de56","modified":1718945184879},{"_id":"public/2024/06/19/imagens/Bubble.png","hash":"a20c3ed466d0e661fa2f396414cf0975d289f7bf","modified":1718945184879},{"_id":"public/2024/06/19/imagens/Insertion.png","hash":"1c181424b0e9fd8e0331a772d1397288b6789c8b","modified":1718945184879},{"_id":"public/2024/06/19/imagens/Selection.png","hash":"3b58254e02c82d4ae7aadc61550b21b424902d7a","modified":1718945184879},{"_id":"public/2024/06/19/imagens/Quick.png","hash":"a4a6f983060f33474f7bf3fac60b75f751b04841","modified":1718945184879},{"_id":"public/2024/06/19/imagens/Tempo.png","hash":"227cf273ded2ede0f618446b88ecca69416d9095","modified":1718945184879}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"Algoritmos de Ordenação","date":"2024-05-13T14:26:17.000Z","_content":"\nDesvendando os Segredos da Ordenação através de Algoritmos \n---\n\nNo mundo da computação, os dados são reis, e a organização é rainha. É aí que entram os algoritmos de ordenação, cavaleiros heroicos que colocam os dados em seus devidos lugares, transformando o caos em ordem.\n\nExistem diversos tipos desses bravos algoritmos, cada um com suas próprias habilidades e vantagens. Alguns são mais estáveis, garantindo que a ordem original dos elementos iguais seja preservada, enquanto outros brilham em termos de performance, ordenando listas com velocidade impressionante. Conheça alguns dos campeões da ordenação:\n\nBubble Sort \n---\n\nO veterano da turma, conhecido por sua simplicidade e facilidade de implementação. Apesar de ser um pouco lento em grandes conjuntos de dados, o Bubble Sort é estável e garante que elementos iguais permaneçam juntos.\n\n{%asset_img Bubble.png%}\n\n```python\ndef bubble_sort(simple_array):\n  max_pos = len(simple_array) - 1\n  count = 0\n\n  while max_pos > 0:\n    if count < max_pos:\n      if simple_array[count] > simple_array[count + 1]:\n        aux = simple_array[count]\n        simple_array[count] = simple_array[count + 1]\n        simple_array[count + 1] = aux\n\n    if count == max_pos:\n      max_pos -= 1\n      count = 0\n    else:\n      count += 1\n```\n{%asset_img Bubble.png%}\n\nSelection Sort\n---\n\nUm algoritmo elegante que encontra o menor elemento da lista e o coloca na sua posição final, repetindo o processo até que todos estejam ordenados. O Selection Sort também é estável, mas pode ser mais lento que o Bubble Sort em casos específicos.\n\n```python\ndef selection_sort(simple_array):\n    n = len(simple_array)\n    for i in range(n):\n        # Encontra o elemento mínimo no array.\n        min_element = i\n        # compara o elemento na posição minimo com todos os outros i + 1 elementos\n        for j in range(i + 1, n):\n            if simple_array[min_element] > simple_array[j]:\n                min_element = j\n        # Coloca o elemento mínimo na posição correspondente.\n        aux = simple_array[i]\n        simple_array[i] = simple_array[min_element] \n        simple_array[min_element] = aux\n```\n\nInsertion Sort\n---\n\nInspirado na organização de cartas na mão, o Insertion Sort insere cada elemento na lista na sua posição correta, comparando-o com os elementos anteriores. É um algoritmo estável e eficiente para pequenos conjuntos de dados, mas pode ser mais lento em listas maiores.\n\n```python\ndef insertion_sort(simple_array):\n    n = len(simple_array)\n\n    for j in range(1, n):\n        chave = simple_array[j]\n        i = j - 1\n        # Insere o elemento simple_array[j] na posição correta.\n        while i >= 0 and simple_array[i] > chave:\n            simple_array[i + 1] = simple_array[i]\n            i = i - 1\n        simple_array[i + 1] = chave\n```\n\nMerge Sort\n---\n\nUm mestre da divisão e conquista, o Merge Sort divide a lista em sublistas menores, ordena-as recursivamente e as junta de forma ordenada. É um algoritmo estável e eficiente, com excelente performance para grandes conjuntos de dados.\n\n```python\ndef merge(simple_array, aux, left, center, right):\n    # Une dois vetores ordenados em um único vetor (também ordenado).\n    for k in range(left, right + 1):\n        aux[k] = simple_array[k]\n    i = left\n    j = center + 1\n    for k in range(left, right + 1):\n        if i > center:\n            simple_array[k] = aux[j]\n            j += 1\n        elif j > right:\n            simple_array[k] = aux[i]\n            i += 1\n        elif aux[j] < aux[i]:\n            simple_array[k] = aux[j]\n            j += 1\n        else:\n            simple_array[k] = aux[i]\n            i += 1\n\ndef merge_sort(simple_array, aux, left, right):\n    if right <= left:\n        return\n    meio = (left + right) // 2\n\n    merge_sort(simple_array, aux, left, meio)\n\n    merge_sort(simple_array, aux, meio + 1, right)\n\n    merge(simple_array, aux, left, meio, right)\n```\n\nQual algoritmo escolher?\n---\n\nA escolha do algoritmo ideal depende das suas necessidades específicas. Se a estabilidade for crucial e a lista for pequena, o Bubble Sort ou o Selection Sort podem ser boas opções. Para listas maiores que exigem alta performance, o Merge Sort é geralmente a melhor escolha. Já o Insertion Sort se destaca em cenários onde as modificações na lista são frequentes, pois requer menos operações de troca de elementos.\n\nLembre-se: a jornada da ordenação é como uma aventura épica, com cada algoritmo oferecendo um caminho único para alcançar a organização perfeita. Explore suas características, compare suas performances e escolha o cavaleiro que melhor se encaixa em sua missão!","source":"_posts/Algoritmos.md","raw":"---\ntitle: Algoritmos de Ordenação\ndate: 2024-05-13 11:26:17\ntags:\n---\n\nDesvendando os Segredos da Ordenação através de Algoritmos \n---\n\nNo mundo da computação, os dados são reis, e a organização é rainha. É aí que entram os algoritmos de ordenação, cavaleiros heroicos que colocam os dados em seus devidos lugares, transformando o caos em ordem.\n\nExistem diversos tipos desses bravos algoritmos, cada um com suas próprias habilidades e vantagens. Alguns são mais estáveis, garantindo que a ordem original dos elementos iguais seja preservada, enquanto outros brilham em termos de performance, ordenando listas com velocidade impressionante. Conheça alguns dos campeões da ordenação:\n\nBubble Sort \n---\n\nO veterano da turma, conhecido por sua simplicidade e facilidade de implementação. Apesar de ser um pouco lento em grandes conjuntos de dados, o Bubble Sort é estável e garante que elementos iguais permaneçam juntos.\n\n{%asset_img Bubble.png%}\n\n```python\ndef bubble_sort(simple_array):\n  max_pos = len(simple_array) - 1\n  count = 0\n\n  while max_pos > 0:\n    if count < max_pos:\n      if simple_array[count] > simple_array[count + 1]:\n        aux = simple_array[count]\n        simple_array[count] = simple_array[count + 1]\n        simple_array[count + 1] = aux\n\n    if count == max_pos:\n      max_pos -= 1\n      count = 0\n    else:\n      count += 1\n```\n{%asset_img Bubble.png%}\n\nSelection Sort\n---\n\nUm algoritmo elegante que encontra o menor elemento da lista e o coloca na sua posição final, repetindo o processo até que todos estejam ordenados. O Selection Sort também é estável, mas pode ser mais lento que o Bubble Sort em casos específicos.\n\n```python\ndef selection_sort(simple_array):\n    n = len(simple_array)\n    for i in range(n):\n        # Encontra o elemento mínimo no array.\n        min_element = i\n        # compara o elemento na posição minimo com todos os outros i + 1 elementos\n        for j in range(i + 1, n):\n            if simple_array[min_element] > simple_array[j]:\n                min_element = j\n        # Coloca o elemento mínimo na posição correspondente.\n        aux = simple_array[i]\n        simple_array[i] = simple_array[min_element] \n        simple_array[min_element] = aux\n```\n\nInsertion Sort\n---\n\nInspirado na organização de cartas na mão, o Insertion Sort insere cada elemento na lista na sua posição correta, comparando-o com os elementos anteriores. É um algoritmo estável e eficiente para pequenos conjuntos de dados, mas pode ser mais lento em listas maiores.\n\n```python\ndef insertion_sort(simple_array):\n    n = len(simple_array)\n\n    for j in range(1, n):\n        chave = simple_array[j]\n        i = j - 1\n        # Insere o elemento simple_array[j] na posição correta.\n        while i >= 0 and simple_array[i] > chave:\n            simple_array[i + 1] = simple_array[i]\n            i = i - 1\n        simple_array[i + 1] = chave\n```\n\nMerge Sort\n---\n\nUm mestre da divisão e conquista, o Merge Sort divide a lista em sublistas menores, ordena-as recursivamente e as junta de forma ordenada. É um algoritmo estável e eficiente, com excelente performance para grandes conjuntos de dados.\n\n```python\ndef merge(simple_array, aux, left, center, right):\n    # Une dois vetores ordenados em um único vetor (também ordenado).\n    for k in range(left, right + 1):\n        aux[k] = simple_array[k]\n    i = left\n    j = center + 1\n    for k in range(left, right + 1):\n        if i > center:\n            simple_array[k] = aux[j]\n            j += 1\n        elif j > right:\n            simple_array[k] = aux[i]\n            i += 1\n        elif aux[j] < aux[i]:\n            simple_array[k] = aux[j]\n            j += 1\n        else:\n            simple_array[k] = aux[i]\n            i += 1\n\ndef merge_sort(simple_array, aux, left, right):\n    if right <= left:\n        return\n    meio = (left + right) // 2\n\n    merge_sort(simple_array, aux, left, meio)\n\n    merge_sort(simple_array, aux, meio + 1, right)\n\n    merge(simple_array, aux, left, meio, right)\n```\n\nQual algoritmo escolher?\n---\n\nA escolha do algoritmo ideal depende das suas necessidades específicas. Se a estabilidade for crucial e a lista for pequena, o Bubble Sort ou o Selection Sort podem ser boas opções. Para listas maiores que exigem alta performance, o Merge Sort é geralmente a melhor escolha. Já o Insertion Sort se destaca em cenários onde as modificações na lista são frequentes, pois requer menos operações de troca de elementos.\n\nLembre-se: a jornada da ordenação é como uma aventura épica, com cada algoritmo oferecendo um caminho único para alcançar a organização perfeita. Explore suas características, compare suas performances e escolha o cavaleiro que melhor se encaixa em sua missão!","slug":"Algoritmos","published":1,"updated":"2024-06-19T22:51:59.126Z","comments":1,"layout":"post","photos":[],"_id":"clxo7bidu00000gum2ey29nof","content":"<h2 id=\"Desvendando-os-Segredos-da-Ordenacao-atraves-de-Algoritmos\"><a href=\"#Desvendando-os-Segredos-da-Ordenacao-atraves-de-Algoritmos\" class=\"headerlink\" title=\"Desvendando os Segredos da Ordenação através de Algoritmos \"></a>Desvendando os Segredos da Ordenação através de Algoritmos </h2><p>No mundo da computação, os dados são reis, e a organização é rainha. É aí que entram os algoritmos de ordenação, cavaleiros heroicos que colocam os dados em seus devidos lugares, transformando o caos em ordem.</p>\n<p>Existem diversos tipos desses bravos algoritmos, cada um com suas próprias habilidades e vantagens. Alguns são mais estáveis, garantindo que a ordem original dos elementos iguais seja preservada, enquanto outros brilham em termos de performance, ordenando listas com velocidade impressionante. Conheça alguns dos campeões da ordenação:</p>\n<h2 id=\"Bubble-Sort\"><a href=\"#Bubble-Sort\" class=\"headerlink\" title=\"Bubble Sort \"></a>Bubble Sort </h2><p>O veterano da turma, conhecido por sua simplicidade e facilidade de implementação. Apesar de ser um pouco lento em grandes conjuntos de dados, o Bubble Sort é estável e garante que elementos iguais permaneçam juntos.</p>\n\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">bubble_sort</span>(<span class=\"params\">simple_array</span>):</span><br><span class=\"line\">  max_pos = <span class=\"built_in\">len</span>(simple_array) - <span class=\"number\">1</span></span><br><span class=\"line\">  count = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">while</span> max_pos &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">    <span class=\"keyword\">if</span> count &lt; max_pos:</span><br><span class=\"line\">      <span class=\"keyword\">if</span> simple_array[count] &gt; simple_array[count + <span class=\"number\">1</span>]:</span><br><span class=\"line\">        aux = simple_array[count]</span><br><span class=\"line\">        simple_array[count] = simple_array[count + <span class=\"number\">1</span>]</span><br><span class=\"line\">        simple_array[count + <span class=\"number\">1</span>] = aux</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> count == max_pos:</span><br><span class=\"line\">      max_pos -= <span class=\"number\">1</span></span><br><span class=\"line\">      count = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">      count += <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"Selection-Sort\"><a href=\"#Selection-Sort\" class=\"headerlink\" title=\"Selection Sort\"></a>Selection Sort</h2><p>Um algoritmo elegante que encontra o menor elemento da lista e o coloca na sua posição final, repetindo o processo até que todos estejam ordenados. O Selection Sort também é estável, mas pode ser mais lento que o Bubble Sort em casos específicos.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">selection_sort</span>(<span class=\"params\">simple_array</span>):</span><br><span class=\"line\">    n = <span class=\"built_in\">len</span>(simple_array)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(n):</span><br><span class=\"line\">        <span class=\"comment\"># Encontra o elemento mínimo no array.</span></span><br><span class=\"line\">        min_element = i</span><br><span class=\"line\">        <span class=\"comment\"># compara o elemento na posição minimo com todos os outros i + 1 elementos</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(i + <span class=\"number\">1</span>, n):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> simple_array[min_element] &gt; simple_array[j]:</span><br><span class=\"line\">                min_element = j</span><br><span class=\"line\">        <span class=\"comment\"># Coloca o elemento mínimo na posição correspondente.</span></span><br><span class=\"line\">        aux = simple_array[i]</span><br><span class=\"line\">        simple_array[i] = simple_array[min_element] </span><br><span class=\"line\">        simple_array[min_element] = aux</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Insertion-Sort\"><a href=\"#Insertion-Sort\" class=\"headerlink\" title=\"Insertion Sort\"></a>Insertion Sort</h2><p>Inspirado na organização de cartas na mão, o Insertion Sort insere cada elemento na lista na sua posição correta, comparando-o com os elementos anteriores. É um algoritmo estável e eficiente para pequenos conjuntos de dados, mas pode ser mais lento em listas maiores.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">insertion_sort</span>(<span class=\"params\">simple_array</span>):</span><br><span class=\"line\">    n = <span class=\"built_in\">len</span>(simple_array)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, n):</span><br><span class=\"line\">        chave = simple_array[j]</span><br><span class=\"line\">        i = j - <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"comment\"># Insere o elemento simple_array[j] na posição correta.</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> i &gt;= <span class=\"number\">0</span> <span class=\"keyword\">and</span> simple_array[i] &gt; chave:</span><br><span class=\"line\">            simple_array[i + <span class=\"number\">1</span>] = simple_array[i]</span><br><span class=\"line\">            i = i - <span class=\"number\">1</span></span><br><span class=\"line\">        simple_array[i + <span class=\"number\">1</span>] = chave</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Merge-Sort\"><a href=\"#Merge-Sort\" class=\"headerlink\" title=\"Merge Sort\"></a>Merge Sort</h2><p>Um mestre da divisão e conquista, o Merge Sort divide a lista em sublistas menores, ordena-as recursivamente e as junta de forma ordenada. É um algoritmo estável e eficiente, com excelente performance para grandes conjuntos de dados.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">merge</span>(<span class=\"params\">simple_array, aux, left, center, right</span>):</span><br><span class=\"line\">    <span class=\"comment\"># Une dois vetores ordenados em um único vetor (também ordenado).</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(left, right + <span class=\"number\">1</span>):</span><br><span class=\"line\">        aux[k] = simple_array[k]</span><br><span class=\"line\">    i = left</span><br><span class=\"line\">    j = center + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(left, right + <span class=\"number\">1</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i &gt; center:</span><br><span class=\"line\">            simple_array[k] = aux[j]</span><br><span class=\"line\">            j += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">elif</span> j &gt; right:</span><br><span class=\"line\">            simple_array[k] = aux[i]</span><br><span class=\"line\">            i += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">elif</span> aux[j] &lt; aux[i]:</span><br><span class=\"line\">            simple_array[k] = aux[j]</span><br><span class=\"line\">            j += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            simple_array[k] = aux[i]</span><br><span class=\"line\">            i += <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">merge_sort</span>(<span class=\"params\">simple_array, aux, left, right</span>):</span><br><span class=\"line\">    <span class=\"keyword\">if</span> right &lt;= left:</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    meio = (left + right) // <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\">    merge_sort(simple_array, aux, left, meio)</span><br><span class=\"line\"></span><br><span class=\"line\">    merge_sort(simple_array, aux, meio + <span class=\"number\">1</span>, right)</span><br><span class=\"line\"></span><br><span class=\"line\">    merge(simple_array, aux, left, meio, right)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Qual-algoritmo-escolher\"><a href=\"#Qual-algoritmo-escolher\" class=\"headerlink\" title=\"Qual algoritmo escolher?\"></a>Qual algoritmo escolher?</h2><p>A escolha do algoritmo ideal depende das suas necessidades específicas. Se a estabilidade for crucial e a lista for pequena, o Bubble Sort ou o Selection Sort podem ser boas opções. Para listas maiores que exigem alta performance, o Merge Sort é geralmente a melhor escolha. Já o Insertion Sort se destaca em cenários onde as modificações na lista são frequentes, pois requer menos operações de troca de elementos.</p>\n<p>Lembre-se: a jornada da ordenação é como uma aventura épica, com cada algoritmo oferecendo um caminho único para alcançar a organização perfeita. Explore suas características, compare suas performances e escolha o cavaleiro que melhor se encaixa em sua missão!</p>\n","excerpt":"","more":"<h2 id=\"Desvendando-os-Segredos-da-Ordenacao-atraves-de-Algoritmos\"><a href=\"#Desvendando-os-Segredos-da-Ordenacao-atraves-de-Algoritmos\" class=\"headerlink\" title=\"Desvendando os Segredos da Ordenação através de Algoritmos \"></a>Desvendando os Segredos da Ordenação através de Algoritmos </h2><p>No mundo da computação, os dados são reis, e a organização é rainha. É aí que entram os algoritmos de ordenação, cavaleiros heroicos que colocam os dados em seus devidos lugares, transformando o caos em ordem.</p>\n<p>Existem diversos tipos desses bravos algoritmos, cada um com suas próprias habilidades e vantagens. Alguns são mais estáveis, garantindo que a ordem original dos elementos iguais seja preservada, enquanto outros brilham em termos de performance, ordenando listas com velocidade impressionante. Conheça alguns dos campeões da ordenação:</p>\n<h2 id=\"Bubble-Sort\"><a href=\"#Bubble-Sort\" class=\"headerlink\" title=\"Bubble Sort \"></a>Bubble Sort </h2><p>O veterano da turma, conhecido por sua simplicidade e facilidade de implementação. Apesar de ser um pouco lento em grandes conjuntos de dados, o Bubble Sort é estável e garante que elementos iguais permaneçam juntos.</p>\n\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">bubble_sort</span>(<span class=\"params\">simple_array</span>):</span><br><span class=\"line\">  max_pos = <span class=\"built_in\">len</span>(simple_array) - <span class=\"number\">1</span></span><br><span class=\"line\">  count = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">while</span> max_pos &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">    <span class=\"keyword\">if</span> count &lt; max_pos:</span><br><span class=\"line\">      <span class=\"keyword\">if</span> simple_array[count] &gt; simple_array[count + <span class=\"number\">1</span>]:</span><br><span class=\"line\">        aux = simple_array[count]</span><br><span class=\"line\">        simple_array[count] = simple_array[count + <span class=\"number\">1</span>]</span><br><span class=\"line\">        simple_array[count + <span class=\"number\">1</span>] = aux</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> count == max_pos:</span><br><span class=\"line\">      max_pos -= <span class=\"number\">1</span></span><br><span class=\"line\">      count = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">      count += <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"Selection-Sort\"><a href=\"#Selection-Sort\" class=\"headerlink\" title=\"Selection Sort\"></a>Selection Sort</h2><p>Um algoritmo elegante que encontra o menor elemento da lista e o coloca na sua posição final, repetindo o processo até que todos estejam ordenados. O Selection Sort também é estável, mas pode ser mais lento que o Bubble Sort em casos específicos.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">selection_sort</span>(<span class=\"params\">simple_array</span>):</span><br><span class=\"line\">    n = <span class=\"built_in\">len</span>(simple_array)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(n):</span><br><span class=\"line\">        <span class=\"comment\"># Encontra o elemento mínimo no array.</span></span><br><span class=\"line\">        min_element = i</span><br><span class=\"line\">        <span class=\"comment\"># compara o elemento na posição minimo com todos os outros i + 1 elementos</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(i + <span class=\"number\">1</span>, n):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> simple_array[min_element] &gt; simple_array[j]:</span><br><span class=\"line\">                min_element = j</span><br><span class=\"line\">        <span class=\"comment\"># Coloca o elemento mínimo na posição correspondente.</span></span><br><span class=\"line\">        aux = simple_array[i]</span><br><span class=\"line\">        simple_array[i] = simple_array[min_element] </span><br><span class=\"line\">        simple_array[min_element] = aux</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Insertion-Sort\"><a href=\"#Insertion-Sort\" class=\"headerlink\" title=\"Insertion Sort\"></a>Insertion Sort</h2><p>Inspirado na organização de cartas na mão, o Insertion Sort insere cada elemento na lista na sua posição correta, comparando-o com os elementos anteriores. É um algoritmo estável e eficiente para pequenos conjuntos de dados, mas pode ser mais lento em listas maiores.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">insertion_sort</span>(<span class=\"params\">simple_array</span>):</span><br><span class=\"line\">    n = <span class=\"built_in\">len</span>(simple_array)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, n):</span><br><span class=\"line\">        chave = simple_array[j]</span><br><span class=\"line\">        i = j - <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"comment\"># Insere o elemento simple_array[j] na posição correta.</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> i &gt;= <span class=\"number\">0</span> <span class=\"keyword\">and</span> simple_array[i] &gt; chave:</span><br><span class=\"line\">            simple_array[i + <span class=\"number\">1</span>] = simple_array[i]</span><br><span class=\"line\">            i = i - <span class=\"number\">1</span></span><br><span class=\"line\">        simple_array[i + <span class=\"number\">1</span>] = chave</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Merge-Sort\"><a href=\"#Merge-Sort\" class=\"headerlink\" title=\"Merge Sort\"></a>Merge Sort</h2><p>Um mestre da divisão e conquista, o Merge Sort divide a lista em sublistas menores, ordena-as recursivamente e as junta de forma ordenada. É um algoritmo estável e eficiente, com excelente performance para grandes conjuntos de dados.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">merge</span>(<span class=\"params\">simple_array, aux, left, center, right</span>):</span><br><span class=\"line\">    <span class=\"comment\"># Une dois vetores ordenados em um único vetor (também ordenado).</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(left, right + <span class=\"number\">1</span>):</span><br><span class=\"line\">        aux[k] = simple_array[k]</span><br><span class=\"line\">    i = left</span><br><span class=\"line\">    j = center + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(left, right + <span class=\"number\">1</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i &gt; center:</span><br><span class=\"line\">            simple_array[k] = aux[j]</span><br><span class=\"line\">            j += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">elif</span> j &gt; right:</span><br><span class=\"line\">            simple_array[k] = aux[i]</span><br><span class=\"line\">            i += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">elif</span> aux[j] &lt; aux[i]:</span><br><span class=\"line\">            simple_array[k] = aux[j]</span><br><span class=\"line\">            j += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            simple_array[k] = aux[i]</span><br><span class=\"line\">            i += <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">merge_sort</span>(<span class=\"params\">simple_array, aux, left, right</span>):</span><br><span class=\"line\">    <span class=\"keyword\">if</span> right &lt;= left:</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    meio = (left + right) // <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\">    merge_sort(simple_array, aux, left, meio)</span><br><span class=\"line\"></span><br><span class=\"line\">    merge_sort(simple_array, aux, meio + <span class=\"number\">1</span>, right)</span><br><span class=\"line\"></span><br><span class=\"line\">    merge(simple_array, aux, left, meio, right)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Qual-algoritmo-escolher\"><a href=\"#Qual-algoritmo-escolher\" class=\"headerlink\" title=\"Qual algoritmo escolher?\"></a>Qual algoritmo escolher?</h2><p>A escolha do algoritmo ideal depende das suas necessidades específicas. Se a estabilidade for crucial e a lista for pequena, o Bubble Sort ou o Selection Sort podem ser boas opções. Para listas maiores que exigem alta performance, o Merge Sort é geralmente a melhor escolha. Já o Insertion Sort se destaca em cenários onde as modificações na lista são frequentes, pois requer menos operações de troca de elementos.</p>\n<p>Lembre-se: a jornada da ordenação é como uma aventura épica, com cada algoritmo oferecendo um caminho único para alcançar a organização perfeita. Explore suas características, compare suas performances e escolha o cavaleiro que melhor se encaixa em sua missão!</p>\n"},{"title":"Busca Binária","date":"2024-05-14T03:00:00.000Z","_content":"Busca binária, é um algoritmo de busca de dados em um array ou lista que funciona repartindo o arranjo ao meio e comparando os resultados quantas vezes forem necessárias. Em outras palavras busca binária é como encontrar um número em um livro grosso, mas em vez de folhear página por página, você abre o livro na metade e vê se o número que você está procurando está na metade superior ou inferior. Se estiver na metade superior, você repete o processo nessa metade; se estiver na metade inferior, você faz o mesmo lá. Isso continua até encontrar o número ou perceber que não está no livro.\n\nUm pré requisito para aplicar a busca binária, é que o arranjo deve estar ordenado, a ordem de separação da busca binária também deve seguir a ordem (crescente ou decrescente).\n\nImplementação em Python\n---\n ```python\ndef binary_search(simple_array, searched_element):\n  while True:\n    len_array = len(simple_array)\n\n    if len_array == 1 and simple_array[0] != searched_element:\n      print(\"O elemento não foi encontrado\")\n      break\n\n    middle_element = simple_array[len_array//2]\n    if middle_element == searched_element:\n      print(\"O elemento foi encontrado\")\n      break\n\n    elif middle_element < searched_element:\n      simple_array = simple_array[len_array//2 + 1:]\n\n    else:\n      simple_array = simple_array[:len_array//2]\n```\n---\nImplementação unida com os algoritmos de ordenação\n---\nA fim de unir o conhecimento a respeito da busca binária com os conceitos de algoritmos de ordenação, criei um notebook no Google Colaboratory, onde a busca binária será aplicada em conjunto com um dos algoritmos de ordenação, o funcionamento acontecerá da seguinte forma:\n\nO usuário poderá montar o array que deseja fazer a busca de elementos caso quiser, caso não, o array usado será gerado pelo algoritmo;\nApós criar o array, o usuário pode escolher um dos 4 algoritmos de ordenação estudados (Bubble Sort, Selection Sort, Insertion Sort e Merge Sort) para ordenar seu array;\nApós isso, será exibido o tempo gasto para ordenar o array, e o usuário poderá buscar por quantos elementos quiser em seu array.","source":"_posts/Busca Binária.md","raw":"---\ntitle: Busca Binária\ndate: 2024-05-14 \ntags:\n---\nBusca binária, é um algoritmo de busca de dados em um array ou lista que funciona repartindo o arranjo ao meio e comparando os resultados quantas vezes forem necessárias. Em outras palavras busca binária é como encontrar um número em um livro grosso, mas em vez de folhear página por página, você abre o livro na metade e vê se o número que você está procurando está na metade superior ou inferior. Se estiver na metade superior, você repete o processo nessa metade; se estiver na metade inferior, você faz o mesmo lá. Isso continua até encontrar o número ou perceber que não está no livro.\n\nUm pré requisito para aplicar a busca binária, é que o arranjo deve estar ordenado, a ordem de separação da busca binária também deve seguir a ordem (crescente ou decrescente).\n\nImplementação em Python\n---\n ```python\ndef binary_search(simple_array, searched_element):\n  while True:\n    len_array = len(simple_array)\n\n    if len_array == 1 and simple_array[0] != searched_element:\n      print(\"O elemento não foi encontrado\")\n      break\n\n    middle_element = simple_array[len_array//2]\n    if middle_element == searched_element:\n      print(\"O elemento foi encontrado\")\n      break\n\n    elif middle_element < searched_element:\n      simple_array = simple_array[len_array//2 + 1:]\n\n    else:\n      simple_array = simple_array[:len_array//2]\n```\n---\nImplementação unida com os algoritmos de ordenação\n---\nA fim de unir o conhecimento a respeito da busca binária com os conceitos de algoritmos de ordenação, criei um notebook no Google Colaboratory, onde a busca binária será aplicada em conjunto com um dos algoritmos de ordenação, o funcionamento acontecerá da seguinte forma:\n\nO usuário poderá montar o array que deseja fazer a busca de elementos caso quiser, caso não, o array usado será gerado pelo algoritmo;\nApós criar o array, o usuário pode escolher um dos 4 algoritmos de ordenação estudados (Bubble Sort, Selection Sort, Insertion Sort e Merge Sort) para ordenar seu array;\nApós isso, será exibido o tempo gasto para ordenar o array, e o usuário poderá buscar por quantos elementos quiser em seu array.","slug":"Busca Binária","published":1,"updated":"2024-06-19T14:13:53.947Z","comments":1,"layout":"post","photos":[],"_id":"clxo7bidy00010gum84u30k2r","content":"<p>Busca binária, é um algoritmo de busca de dados em um array ou lista que funciona repartindo o arranjo ao meio e comparando os resultados quantas vezes forem necessárias. Em outras palavras busca binária é como encontrar um número em um livro grosso, mas em vez de folhear página por página, você abre o livro na metade e vê se o número que você está procurando está na metade superior ou inferior. Se estiver na metade superior, você repete o processo nessa metade; se estiver na metade inferior, você faz o mesmo lá. Isso continua até encontrar o número ou perceber que não está no livro.</p>\n<p>Um pré requisito para aplicar a busca binária, é que o arranjo deve estar ordenado, a ordem de separação da busca binária também deve seguir a ordem (crescente ou decrescente).</p>\n<h2 id=\"Implementacao-em-Python\"><a href=\"#Implementacao-em-Python\" class=\"headerlink\" title=\"Implementação em Python\"></a>Implementação em Python</h2> <figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">binary_search</span>(<span class=\"params\">simple_array, searched_element</span>):</span><br><span class=\"line\">  <span class=\"keyword\">while</span> <span class=\"literal\">True</span>:</span><br><span class=\"line\">    len_array = <span class=\"built_in\">len</span>(simple_array)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> len_array == <span class=\"number\">1</span> <span class=\"keyword\">and</span> simple_array[<span class=\"number\">0</span>] != searched_element:</span><br><span class=\"line\">      <span class=\"built_in\">print</span>(<span class=\"string\">&quot;O elemento não foi encontrado&quot;</span>)</span><br><span class=\"line\">      <span class=\"keyword\">break</span></span><br><span class=\"line\"></span><br><span class=\"line\">    middle_element = simple_array[len_array//<span class=\"number\">2</span>]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> middle_element == searched_element:</span><br><span class=\"line\">      <span class=\"built_in\">print</span>(<span class=\"string\">&quot;O elemento foi encontrado&quot;</span>)</span><br><span class=\"line\">      <span class=\"keyword\">break</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">elif</span> middle_element &lt; searched_element:</span><br><span class=\"line\">      simple_array = simple_array[len_array//<span class=\"number\">2</span> + <span class=\"number\">1</span>:]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">      simple_array = simple_array[:len_array//<span class=\"number\">2</span>]</span><br></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"Implementacao-unida-com-os-algoritmos-de-ordenacao\"><a href=\"#Implementacao-unida-com-os-algoritmos-de-ordenacao\" class=\"headerlink\" title=\"Implementação unida com os algoritmos de ordenação\"></a>Implementação unida com os algoritmos de ordenação</h2><p>A fim de unir o conhecimento a respeito da busca binária com os conceitos de algoritmos de ordenação, criei um notebook no Google Colaboratory, onde a busca binária será aplicada em conjunto com um dos algoritmos de ordenação, o funcionamento acontecerá da seguinte forma:</p>\n<p>O usuário poderá montar o array que deseja fazer a busca de elementos caso quiser, caso não, o array usado será gerado pelo algoritmo;<br>Após criar o array, o usuário pode escolher um dos 4 algoritmos de ordenação estudados (Bubble Sort, Selection Sort, Insertion Sort e Merge Sort) para ordenar seu array;<br>Após isso, será exibido o tempo gasto para ordenar o array, e o usuário poderá buscar por quantos elementos quiser em seu array.</p>\n","excerpt":"","more":"<p>Busca binária, é um algoritmo de busca de dados em um array ou lista que funciona repartindo o arranjo ao meio e comparando os resultados quantas vezes forem necessárias. Em outras palavras busca binária é como encontrar um número em um livro grosso, mas em vez de folhear página por página, você abre o livro na metade e vê se o número que você está procurando está na metade superior ou inferior. Se estiver na metade superior, você repete o processo nessa metade; se estiver na metade inferior, você faz o mesmo lá. Isso continua até encontrar o número ou perceber que não está no livro.</p>\n<p>Um pré requisito para aplicar a busca binária, é que o arranjo deve estar ordenado, a ordem de separação da busca binária também deve seguir a ordem (crescente ou decrescente).</p>\n<h2 id=\"Implementacao-em-Python\"><a href=\"#Implementacao-em-Python\" class=\"headerlink\" title=\"Implementação em Python\"></a>Implementação em Python</h2> <figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">binary_search</span>(<span class=\"params\">simple_array, searched_element</span>):</span><br><span class=\"line\">  <span class=\"keyword\">while</span> <span class=\"literal\">True</span>:</span><br><span class=\"line\">    len_array = <span class=\"built_in\">len</span>(simple_array)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> len_array == <span class=\"number\">1</span> <span class=\"keyword\">and</span> simple_array[<span class=\"number\">0</span>] != searched_element:</span><br><span class=\"line\">      <span class=\"built_in\">print</span>(<span class=\"string\">&quot;O elemento não foi encontrado&quot;</span>)</span><br><span class=\"line\">      <span class=\"keyword\">break</span></span><br><span class=\"line\"></span><br><span class=\"line\">    middle_element = simple_array[len_array//<span class=\"number\">2</span>]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> middle_element == searched_element:</span><br><span class=\"line\">      <span class=\"built_in\">print</span>(<span class=\"string\">&quot;O elemento foi encontrado&quot;</span>)</span><br><span class=\"line\">      <span class=\"keyword\">break</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">elif</span> middle_element &lt; searched_element:</span><br><span class=\"line\">      simple_array = simple_array[len_array//<span class=\"number\">2</span> + <span class=\"number\">1</span>:]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">      simple_array = simple_array[:len_array//<span class=\"number\">2</span>]</span><br></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"Implementacao-unida-com-os-algoritmos-de-ordenacao\"><a href=\"#Implementacao-unida-com-os-algoritmos-de-ordenacao\" class=\"headerlink\" title=\"Implementação unida com os algoritmos de ordenação\"></a>Implementação unida com os algoritmos de ordenação</h2><p>A fim de unir o conhecimento a respeito da busca binária com os conceitos de algoritmos de ordenação, criei um notebook no Google Colaboratory, onde a busca binária será aplicada em conjunto com um dos algoritmos de ordenação, o funcionamento acontecerá da seguinte forma:</p>\n<p>O usuário poderá montar o array que deseja fazer a busca de elementos caso quiser, caso não, o array usado será gerado pelo algoritmo;<br>Após criar o array, o usuário pode escolher um dos 4 algoritmos de ordenação estudados (Bubble Sort, Selection Sort, Insertion Sort e Merge Sort) para ordenar seu array;<br>Após isso, será exibido o tempo gasto para ordenar o array, e o usuário poderá buscar por quantos elementos quiser em seu array.</p>\n"},{"title":"Curva de tendência dos Algoritmos","date":"2024-06-19T23:20:16.000Z","_content":"Análise Detalhada dos Algoritmos de Ordenação: Uma Jornada Através da Eficiência\n---\n\nNesta sessão, embarcaremos em uma profunda análise da curva de tendência de quatro algoritmos de ordenação renomados: Bubble Sort, Selection Sort, Insertion Sort e Merge Sort. Usando como base os dados da tabela de análise de performance e gráficos, desvendaremos as características e o comportamento de cada algoritmo em relação ao tempo gasto para ordenar arrays de tamanhos variados.\n\nGráficos\n---\nA seguir, temos os gráficos de cada algoritmo de ordenação juntamente com a curva de tendência de cada um, exibidos nos gráficos e referenciados por sua pesquisa correspondente, gerada com auxílio da ferramenta Google Planilhas.\n\nGráfico do Bubble\n---\nO gráfico está ilustrando a relação entre o número de elementos a serem ordenados (quantidade de dados) e o tempo que o algoritmo Bubble Sort leva para completar a ordenação. Como esperado para o Bubble Sort, o tempo de execução aumenta de forma não linear à medida que o número de elementos cresce, seguindo aproximadamente uma relação quadrática, o que é indicado pela equação da linha de tendência.\n\n{%asset_img Bubble.png%}\n\nGráfico do Insertion\n---\n\nO gráfico mostra que a complexidade de tempo do algoritmo de classificação por inserção parece crescer quadraticamente com o número de entradas, conforme esperado (a classificação por inserção normalmente tem uma complexidade de tempo de 𝑂(𝑛2)^​​2) nos piores e médios casos. Os pontos de dados azuis mostram as medições reais de desempenho e a curva vermelha mostra que um polinômio quadrático pode modelar efetivamente o desempenho observado.\n\n{%asset_img Insertion.png%}\n\nGráfico Quick\n---\n\nO gráfico demonstra que o algoritmo Quick Sort é dimensionado de acordo com o tamanho dos dados de entrada, mostrando uma relação aproximadamente linear entre o tamanho da entrada e o tempo decorrido, com alguns pequenos desvios. O desempenho real (linha azul) está razoavelmente próximo do desempenho teórico esperado (linha vermelha), validando a eficiência do Quick Sort e seu comportamento de escalabilidade previsível para conjuntos de dados maiores.\n\n{%asset_img Quick.png%}\n\nGráfico Merge\n---\n\nO gráfico mostra que o tempo de execução do Merge Sort aumenta linearmente à medida que a\nquantidade de entradas cresce. A linha de tendência linear sugere uma boa aproximação, com um\n𝑅2R2 alto, indicando que o tempo de execução do Merge Sort é aproximadamente proporcional ao número de entradas, dentro do intervalo testado. Os valores específicos de tempo variam de 2,4 a 53,5 para quantidades de entradas de 5.000 a 40.000, mostrando que, conforme esperado, algoritmos de ordenação consomem mais tempo para maiores quantidades de dados.\n\n{%asset_img Merge.png%}\n\nGráfico Selection\n---\n\nA classificação por seleção é geralmente conhecida por ter uma complexidade de tempo de O(n²), o que significa que o tempo necessário para classificar os elementos cresce quadraticamente com o número de elementos. Esta natureza quadrática é refletida nos termos polinomiais, particularmente no 𝑥2*2 prazo.O gráfico visualiza efetivamente como o tempo necessário para classificar aumenta à medida que o número de elementos aumenta, e o ajuste polinomial fornece uma relação matemática mais precisa entre os dois.\n\n{%asset_img Selection.png%}\n\nTodos o Gráficos\n---\n\n<strong>Bubble Sort (Vermelho):</strong>Tem o pior desempenho em termos de tempo de execução, crescendo rapidamente conforme o número de elementos aumenta. Isso é esperado, já que o Bubble Sort tem complexidade 𝑂(𝑛2)O(n2).\n\n<strong>Selection Sort (Azul):</strong> Desempenho um pouco melhor que o Bubble Sort, mas ainda assim cresce rapidamente e tem complexidade \n𝑂(𝑛2)O(n 2).\n\n<strong>Insertion Sort (Verde):</strong>Desempenha melhor que o Bubble Sort e o Selection Sort, mas também tem complexidade \n𝑂(𝑛2)O(n 2), embora geralmente tenha um desempenho melhor em listas quase ordenadas.\n\n<strong>Quick Sort (Amarelo):</strong>Mostra um desempenho muito melhor, crescendo mais lentamente em comparação com os algoritmos acima. O Quick Sort tem complexidade média 𝑂(𝑛log𝑛) O(nlogn), o que o torna eficiente para grandes conjuntos de dados.\n\n<strong>Merge Sort (Roxo):</strong>Apresenta desempenho similar ao Quick Sort com complexidade 𝑂(𝑛log𝑛) O(nlogn). O tempo de execução cresce lentamente com o aumento do tamanho da entrada, o que mostra sua eficiência em grandes conjuntos de dados.\n{%asset_img Tempo.png%}\n","source":"_posts/imagens.md","raw":"---\ntitle: Curva de tendência dos Algoritmos\ndate: 2024-06-19 20:20:16\ntags:\n---\nAnálise Detalhada dos Algoritmos de Ordenação: Uma Jornada Através da Eficiência\n---\n\nNesta sessão, embarcaremos em uma profunda análise da curva de tendência de quatro algoritmos de ordenação renomados: Bubble Sort, Selection Sort, Insertion Sort e Merge Sort. Usando como base os dados da tabela de análise de performance e gráficos, desvendaremos as características e o comportamento de cada algoritmo em relação ao tempo gasto para ordenar arrays de tamanhos variados.\n\nGráficos\n---\nA seguir, temos os gráficos de cada algoritmo de ordenação juntamente com a curva de tendência de cada um, exibidos nos gráficos e referenciados por sua pesquisa correspondente, gerada com auxílio da ferramenta Google Planilhas.\n\nGráfico do Bubble\n---\nO gráfico está ilustrando a relação entre o número de elementos a serem ordenados (quantidade de dados) e o tempo que o algoritmo Bubble Sort leva para completar a ordenação. Como esperado para o Bubble Sort, o tempo de execução aumenta de forma não linear à medida que o número de elementos cresce, seguindo aproximadamente uma relação quadrática, o que é indicado pela equação da linha de tendência.\n\n{%asset_img Bubble.png%}\n\nGráfico do Insertion\n---\n\nO gráfico mostra que a complexidade de tempo do algoritmo de classificação por inserção parece crescer quadraticamente com o número de entradas, conforme esperado (a classificação por inserção normalmente tem uma complexidade de tempo de 𝑂(𝑛2)^​​2) nos piores e médios casos. Os pontos de dados azuis mostram as medições reais de desempenho e a curva vermelha mostra que um polinômio quadrático pode modelar efetivamente o desempenho observado.\n\n{%asset_img Insertion.png%}\n\nGráfico Quick\n---\n\nO gráfico demonstra que o algoritmo Quick Sort é dimensionado de acordo com o tamanho dos dados de entrada, mostrando uma relação aproximadamente linear entre o tamanho da entrada e o tempo decorrido, com alguns pequenos desvios. O desempenho real (linha azul) está razoavelmente próximo do desempenho teórico esperado (linha vermelha), validando a eficiência do Quick Sort e seu comportamento de escalabilidade previsível para conjuntos de dados maiores.\n\n{%asset_img Quick.png%}\n\nGráfico Merge\n---\n\nO gráfico mostra que o tempo de execução do Merge Sort aumenta linearmente à medida que a\nquantidade de entradas cresce. A linha de tendência linear sugere uma boa aproximação, com um\n𝑅2R2 alto, indicando que o tempo de execução do Merge Sort é aproximadamente proporcional ao número de entradas, dentro do intervalo testado. Os valores específicos de tempo variam de 2,4 a 53,5 para quantidades de entradas de 5.000 a 40.000, mostrando que, conforme esperado, algoritmos de ordenação consomem mais tempo para maiores quantidades de dados.\n\n{%asset_img Merge.png%}\n\nGráfico Selection\n---\n\nA classificação por seleção é geralmente conhecida por ter uma complexidade de tempo de O(n²), o que significa que o tempo necessário para classificar os elementos cresce quadraticamente com o número de elementos. Esta natureza quadrática é refletida nos termos polinomiais, particularmente no 𝑥2*2 prazo.O gráfico visualiza efetivamente como o tempo necessário para classificar aumenta à medida que o número de elementos aumenta, e o ajuste polinomial fornece uma relação matemática mais precisa entre os dois.\n\n{%asset_img Selection.png%}\n\nTodos o Gráficos\n---\n\n<strong>Bubble Sort (Vermelho):</strong>Tem o pior desempenho em termos de tempo de execução, crescendo rapidamente conforme o número de elementos aumenta. Isso é esperado, já que o Bubble Sort tem complexidade 𝑂(𝑛2)O(n2).\n\n<strong>Selection Sort (Azul):</strong> Desempenho um pouco melhor que o Bubble Sort, mas ainda assim cresce rapidamente e tem complexidade \n𝑂(𝑛2)O(n 2).\n\n<strong>Insertion Sort (Verde):</strong>Desempenha melhor que o Bubble Sort e o Selection Sort, mas também tem complexidade \n𝑂(𝑛2)O(n 2), embora geralmente tenha um desempenho melhor em listas quase ordenadas.\n\n<strong>Quick Sort (Amarelo):</strong>Mostra um desempenho muito melhor, crescendo mais lentamente em comparação com os algoritmos acima. O Quick Sort tem complexidade média 𝑂(𝑛log𝑛) O(nlogn), o que o torna eficiente para grandes conjuntos de dados.\n\n<strong>Merge Sort (Roxo):</strong>Apresenta desempenho similar ao Quick Sort com complexidade 𝑂(𝑛log𝑛) O(nlogn). O tempo de execução cresce lentamente com o aumento do tamanho da entrada, o que mostra sua eficiência em grandes conjuntos de dados.\n{%asset_img Tempo.png%}\n","slug":"imagens","published":1,"updated":"2024-06-21T00:14:52.630Z","comments":1,"layout":"post","photos":[],"_id":"clxo7kxkb0000gwum0xh121wd","content":"<h2 id=\"Analise-Detalhada-dos-Algoritmos-de-Ordenacao-Uma-Jornada-Atraves-da-Eficiencia\"><a href=\"#Analise-Detalhada-dos-Algoritmos-de-Ordenacao-Uma-Jornada-Atraves-da-Eficiencia\" class=\"headerlink\" title=\"Análise Detalhada dos Algoritmos de Ordenação: Uma Jornada Através da Eficiência\"></a>Análise Detalhada dos Algoritmos de Ordenação: Uma Jornada Através da Eficiência</h2><p>Nesta sessão, embarcaremos em uma profunda análise da curva de tendência de quatro algoritmos de ordenação renomados: Bubble Sort, Selection Sort, Insertion Sort e Merge Sort. Usando como base os dados da tabela de análise de performance e gráficos, desvendaremos as características e o comportamento de cada algoritmo em relação ao tempo gasto para ordenar arrays de tamanhos variados.</p>\n<h2 id=\"Graficos\"><a href=\"#Graficos\" class=\"headerlink\" title=\"Gráficos\"></a>Gráficos</h2><p>A seguir, temos os gráficos de cada algoritmo de ordenação juntamente com a curva de tendência de cada um, exibidos nos gráficos e referenciados por sua pesquisa correspondente, gerada com auxílio da ferramenta Google Planilhas.</p>\n<h2 id=\"Grafico-do-Bubble\"><a href=\"#Grafico-do-Bubble\" class=\"headerlink\" title=\"Gráfico do Bubble\"></a>Gráfico do Bubble</h2><p>O gráfico está ilustrando a relação entre o número de elementos a serem ordenados (quantidade de dados) e o tempo que o algoritmo Bubble Sort leva para completar a ordenação. Como esperado para o Bubble Sort, o tempo de execução aumenta de forma não linear à medida que o número de elementos cresce, seguindo aproximadamente uma relação quadrática, o que é indicado pela equação da linha de tendência.</p>\n<img src=\"/Site-Hexo/2024/06/19/imagens/Bubble.png\" class=\"\">\n\n<h2 id=\"Grafico-do-Insertion\"><a href=\"#Grafico-do-Insertion\" class=\"headerlink\" title=\"Gráfico do Insertion\"></a>Gráfico do Insertion</h2><p>O gráfico mostra que a complexidade de tempo do algoritmo de classificação por inserção parece crescer quadraticamente com o número de entradas, conforme esperado (a classificação por inserção normalmente tem uma complexidade de tempo de 𝑂(𝑛2)^​​2) nos piores e médios casos. Os pontos de dados azuis mostram as medições reais de desempenho e a curva vermelha mostra que um polinômio quadrático pode modelar efetivamente o desempenho observado.</p>\n<img src=\"/Site-Hexo/2024/06/19/imagens/Insertion.png\" class=\"\">\n\n<h2 id=\"Grafico-Quick\"><a href=\"#Grafico-Quick\" class=\"headerlink\" title=\"Gráfico Quick\"></a>Gráfico Quick</h2><p>O gráfico demonstra que o algoritmo Quick Sort é dimensionado de acordo com o tamanho dos dados de entrada, mostrando uma relação aproximadamente linear entre o tamanho da entrada e o tempo decorrido, com alguns pequenos desvios. O desempenho real (linha azul) está razoavelmente próximo do desempenho teórico esperado (linha vermelha), validando a eficiência do Quick Sort e seu comportamento de escalabilidade previsível para conjuntos de dados maiores.</p>\n<img src=\"/Site-Hexo/2024/06/19/imagens/Quick.png\" class=\"\">\n\n<h2 id=\"Grafico-Merge\"><a href=\"#Grafico-Merge\" class=\"headerlink\" title=\"Gráfico Merge\"></a>Gráfico Merge</h2><p>O gráfico mostra que o tempo de execução do Merge Sort aumenta linearmente à medida que a<br>quantidade de entradas cresce. A linha de tendência linear sugere uma boa aproximação, com um<br>𝑅2R2 alto, indicando que o tempo de execução do Merge Sort é aproximadamente proporcional ao número de entradas, dentro do intervalo testado. Os valores específicos de tempo variam de 2,4 a 53,5 para quantidades de entradas de 5.000 a 40.000, mostrando que, conforme esperado, algoritmos de ordenação consomem mais tempo para maiores quantidades de dados.</p>\n<img src=\"/Site-Hexo/2024/06/19/imagens/Merge.png\" class=\"\">\n\n<h2 id=\"Grafico-Selection\"><a href=\"#Grafico-Selection\" class=\"headerlink\" title=\"Gráfico Selection\"></a>Gráfico Selection</h2><p>A classificação por seleção é geralmente conhecida por ter uma complexidade de tempo de O(n²), o que significa que o tempo necessário para classificar os elementos cresce quadraticamente com o número de elementos. Esta natureza quadrática é refletida nos termos polinomiais, particularmente no 𝑥2*2 prazo.O gráfico visualiza efetivamente como o tempo necessário para classificar aumenta à medida que o número de elementos aumenta, e o ajuste polinomial fornece uma relação matemática mais precisa entre os dois.</p>\n<img src=\"/Site-Hexo/2024/06/19/imagens/Selection.png\" class=\"\">\n\n<h2 id=\"Todos-o-Graficos\"><a href=\"#Todos-o-Graficos\" class=\"headerlink\" title=\"Todos o Gráficos\"></a>Todos o Gráficos</h2><p><strong>Bubble Sort (Vermelho):</strong>Tem o pior desempenho em termos de tempo de execução, crescendo rapidamente conforme o número de elementos aumenta. Isso é esperado, já que o Bubble Sort tem complexidade 𝑂(𝑛2)O(n2).</p>\n<p><strong>Selection Sort (Azul):</strong> Desempenho um pouco melhor que o Bubble Sort, mas ainda assim cresce rapidamente e tem complexidade<br>𝑂(𝑛2)O(n 2).</p>\n<p><strong>Insertion Sort (Verde):</strong>Desempenha melhor que o Bubble Sort e o Selection Sort, mas também tem complexidade<br>𝑂(𝑛2)O(n 2), embora geralmente tenha um desempenho melhor em listas quase ordenadas.</p>\n<p><strong>Quick Sort (Amarelo):</strong>Mostra um desempenho muito melhor, crescendo mais lentamente em comparação com os algoritmos acima. O Quick Sort tem complexidade média 𝑂(𝑛log𝑛) O(nlogn), o que o torna eficiente para grandes conjuntos de dados.</p>\n<p><strong>Merge Sort (Roxo):</strong>Apresenta desempenho similar ao Quick Sort com complexidade 𝑂(𝑛log𝑛) O(nlogn). O tempo de execução cresce lentamente com o aumento do tamanho da entrada, o que mostra sua eficiência em grandes conjuntos de dados.</p>\n<img src=\"/Site-Hexo/2024/06/19/imagens/Tempo.png\" class=\"\">\n","excerpt":"","more":"<h2 id=\"Analise-Detalhada-dos-Algoritmos-de-Ordenacao-Uma-Jornada-Atraves-da-Eficiencia\"><a href=\"#Analise-Detalhada-dos-Algoritmos-de-Ordenacao-Uma-Jornada-Atraves-da-Eficiencia\" class=\"headerlink\" title=\"Análise Detalhada dos Algoritmos de Ordenação: Uma Jornada Através da Eficiência\"></a>Análise Detalhada dos Algoritmos de Ordenação: Uma Jornada Através da Eficiência</h2><p>Nesta sessão, embarcaremos em uma profunda análise da curva de tendência de quatro algoritmos de ordenação renomados: Bubble Sort, Selection Sort, Insertion Sort e Merge Sort. Usando como base os dados da tabela de análise de performance e gráficos, desvendaremos as características e o comportamento de cada algoritmo em relação ao tempo gasto para ordenar arrays de tamanhos variados.</p>\n<h2 id=\"Graficos\"><a href=\"#Graficos\" class=\"headerlink\" title=\"Gráficos\"></a>Gráficos</h2><p>A seguir, temos os gráficos de cada algoritmo de ordenação juntamente com a curva de tendência de cada um, exibidos nos gráficos e referenciados por sua pesquisa correspondente, gerada com auxílio da ferramenta Google Planilhas.</p>\n<h2 id=\"Grafico-do-Bubble\"><a href=\"#Grafico-do-Bubble\" class=\"headerlink\" title=\"Gráfico do Bubble\"></a>Gráfico do Bubble</h2><p>O gráfico está ilustrando a relação entre o número de elementos a serem ordenados (quantidade de dados) e o tempo que o algoritmo Bubble Sort leva para completar a ordenação. Como esperado para o Bubble Sort, o tempo de execução aumenta de forma não linear à medida que o número de elementos cresce, seguindo aproximadamente uma relação quadrática, o que é indicado pela equação da linha de tendência.</p>\n<img src=\"/Site-Hexo/2024/06/19/imagens/Bubble.png\" class=\"\">\n\n<h2 id=\"Grafico-do-Insertion\"><a href=\"#Grafico-do-Insertion\" class=\"headerlink\" title=\"Gráfico do Insertion\"></a>Gráfico do Insertion</h2><p>O gráfico mostra que a complexidade de tempo do algoritmo de classificação por inserção parece crescer quadraticamente com o número de entradas, conforme esperado (a classificação por inserção normalmente tem uma complexidade de tempo de 𝑂(𝑛2)^​​2) nos piores e médios casos. Os pontos de dados azuis mostram as medições reais de desempenho e a curva vermelha mostra que um polinômio quadrático pode modelar efetivamente o desempenho observado.</p>\n<img src=\"/Site-Hexo/2024/06/19/imagens/Insertion.png\" class=\"\">\n\n<h2 id=\"Grafico-Quick\"><a href=\"#Grafico-Quick\" class=\"headerlink\" title=\"Gráfico Quick\"></a>Gráfico Quick</h2><p>O gráfico demonstra que o algoritmo Quick Sort é dimensionado de acordo com o tamanho dos dados de entrada, mostrando uma relação aproximadamente linear entre o tamanho da entrada e o tempo decorrido, com alguns pequenos desvios. O desempenho real (linha azul) está razoavelmente próximo do desempenho teórico esperado (linha vermelha), validando a eficiência do Quick Sort e seu comportamento de escalabilidade previsível para conjuntos de dados maiores.</p>\n<img src=\"/Site-Hexo/2024/06/19/imagens/Quick.png\" class=\"\">\n\n<h2 id=\"Grafico-Merge\"><a href=\"#Grafico-Merge\" class=\"headerlink\" title=\"Gráfico Merge\"></a>Gráfico Merge</h2><p>O gráfico mostra que o tempo de execução do Merge Sort aumenta linearmente à medida que a<br>quantidade de entradas cresce. A linha de tendência linear sugere uma boa aproximação, com um<br>𝑅2R2 alto, indicando que o tempo de execução do Merge Sort é aproximadamente proporcional ao número de entradas, dentro do intervalo testado. Os valores específicos de tempo variam de 2,4 a 53,5 para quantidades de entradas de 5.000 a 40.000, mostrando que, conforme esperado, algoritmos de ordenação consomem mais tempo para maiores quantidades de dados.</p>\n<img src=\"/Site-Hexo/2024/06/19/imagens/Merge.png\" class=\"\">\n\n<h2 id=\"Grafico-Selection\"><a href=\"#Grafico-Selection\" class=\"headerlink\" title=\"Gráfico Selection\"></a>Gráfico Selection</h2><p>A classificação por seleção é geralmente conhecida por ter uma complexidade de tempo de O(n²), o que significa que o tempo necessário para classificar os elementos cresce quadraticamente com o número de elementos. Esta natureza quadrática é refletida nos termos polinomiais, particularmente no 𝑥2*2 prazo.O gráfico visualiza efetivamente como o tempo necessário para classificar aumenta à medida que o número de elementos aumenta, e o ajuste polinomial fornece uma relação matemática mais precisa entre os dois.</p>\n<img src=\"/Site-Hexo/2024/06/19/imagens/Selection.png\" class=\"\">\n\n<h2 id=\"Todos-o-Graficos\"><a href=\"#Todos-o-Graficos\" class=\"headerlink\" title=\"Todos o Gráficos\"></a>Todos o Gráficos</h2><p><strong>Bubble Sort (Vermelho):</strong>Tem o pior desempenho em termos de tempo de execução, crescendo rapidamente conforme o número de elementos aumenta. Isso é esperado, já que o Bubble Sort tem complexidade 𝑂(𝑛2)O(n2).</p>\n<p><strong>Selection Sort (Azul):</strong> Desempenho um pouco melhor que o Bubble Sort, mas ainda assim cresce rapidamente e tem complexidade<br>𝑂(𝑛2)O(n 2).</p>\n<p><strong>Insertion Sort (Verde):</strong>Desempenha melhor que o Bubble Sort e o Selection Sort, mas também tem complexidade<br>𝑂(𝑛2)O(n 2), embora geralmente tenha um desempenho melhor em listas quase ordenadas.</p>\n<p><strong>Quick Sort (Amarelo):</strong>Mostra um desempenho muito melhor, crescendo mais lentamente em comparação com os algoritmos acima. O Quick Sort tem complexidade média 𝑂(𝑛log𝑛) O(nlogn), o que o torna eficiente para grandes conjuntos de dados.</p>\n<p><strong>Merge Sort (Roxo):</strong>Apresenta desempenho similar ao Quick Sort com complexidade 𝑂(𝑛log𝑛) O(nlogn). O tempo de execução cresce lentamente com o aumento do tamanho da entrada, o que mostra sua eficiência em grandes conjuntos de dados.</p>\n<img src=\"/Site-Hexo/2024/06/19/imagens/Tempo.png\" class=\"\">\n"}],"PostAsset":[{"_id":"source\\_posts\\imagens\\Bubble.png","post":"clxo7kxkb0000gwum0xh121wd","slug":"Bubble.png","modified":1,"renderable":0},{"_id":"source\\_posts\\imagens\\Insertion.png","post":"clxo7kxkb0000gwum0xh121wd","slug":"Insertion.png","modified":1,"renderable":0},{"_id":"source\\_posts\\imagens\\Merge.png","post":"clxo7kxkb0000gwum0xh121wd","slug":"Merge.png","modified":1,"renderable":0},{"_id":"source\\_posts\\imagens\\Quick.png","post":"clxo7kxkb0000gwum0xh121wd","slug":"Quick.png","modified":1,"renderable":0},{"_id":"source\\_posts\\imagens\\Selection.png","post":"clxo7kxkb0000gwum0xh121wd","slug":"Selection.png","modified":1,"renderable":0},{"_id":"source\\_posts\\imagens\\Tempo.png","post":"clxo7kxkb0000gwum0xh121wd","slug":"Tempo.png","modified":1,"renderable":0}],"PostCategory":[],"PostTag":[],"Tag":[]}}